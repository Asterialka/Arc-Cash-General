#include <stdio.h>
#include <stdlib.h>
#include "hasH.c"

typedef struct cash_ARC cash_ARC;

#define _T1_ 1
#define _T2_ 2
#define _B1_ 3
#define _B2_ 4

int min(int a, int b)
{
	if (a > b)
	{
		return b;
	}
	else
	{
		return a;
	}
}

int max(int a, int b)
{
	if (a > b)
	{
		return a;
	}
	else
	{
		return b;
	}
}

struct cash_ARC
{
	int size_ARC;	// size c 
	LinkedList * T1;
	LinkedList * B1;
	LinkedList * T2;
	LinkedList * B2;
	int *p;	// parametr thar regul 
	Hash * hash_ARC;	// hash_table size c

};

cash_ARC* init_cash(int size_of_cash)
{
	cash_ARC *cash = (cash_ARC*) malloc(sizeof(cash_ARC));
	cash->T1 = init_List(0, 1);	//init with 0 linked list
	cash->T2 = init_List(0, 2);	//init with 0 linked list
	cash->B1 = init_List(0, 3);	//init with 0 linked list
	cash->B2 = init_List(0, 4);	//init with 0 linked list
	cash->hash_ARC = create_HASH_TABLE(size_of_cash);	//size 2c
	cash->p = 0;
	cash->size_ARC = size_of_cash;
	return cash;
}

void free_cash(cash_ARC *cash)
{
	list_free(&cash->T1);
	list_free(&cash->T2);
	list_free(&cash->B1);
	list_free(&cash->B2);
	free_hash(cash->hash_ARC);
}

void ARC(cash_ARC *ARC, int page)
{
	hashnode *tmp = find_element_in_hash(ARC->hash_ARC, page);
	if (tmp != NULL)
	{
		node *ptr = tmp->point;
		hash_delete_elem(page, ARC->hash_ARC);
		if (find_element(ARC->T1, page) != NULL)
		{
			ARC->T1 = delete_by_point(ptr, ARC->T1);
			print_list(ARC->T1);
			printf("q");
		}
		else
		{
			ARC->T2 = delete_by_point(ptr, ARC->T2);
			printf("w");
		}

		pushFront(ARC->T2, page);
		hashTableAdd(ARC->hash_ARC, ARC->T2->head, page, 2);
		printf("e");
	}
	else if (find_element(ARC->B1, page) != NULL)
	{
		*(ARC->p) = min(ARC->size_ARC, *(ARC->p) + max(ARC->B2->now_size / ARC->B1->now_size, 1));
		replace(ARC, page);
		pushFront(ARC->T2, page);
		hashTableAdd(ARC->hash_ARC, ARC->T2->head, page, 2);
		printf("r");
	}
	else if (find_element(ARC->B2, page) != NULL)
	{
		*(ARC->p) = max(0, *(ARC->p) - max(ARC->B1->now_size / ARC->B2->now_size, 1));
		replace(ARC, page);
		pushFront(ARC->T2, page);
		hashTableAdd(ARC->hash_ARC, ARC->T2->head, page, 2);
		printf("t");
	}
	else
	{
		if ((ARC->B1->now_size + ARC->T1->now_size) == ARC->size_ARC)
		{
			if (ARC->T1->now_size < ARC->size_ARC)
			{
				popBack(ARC->B1);
				replace(ARC, page);
				printf("u");
			}
			else
			{
				int page = ARC->T1->tail->val;
				popBack(ARC->T1);
				hash_delete_elem(page, ARC->hash_ARC);
				printf("i");
			}
		}
		else if (((ARC->B1->now_size + ARC->T1->now_size) < ARC->size_ARC) && (((ARC->B1->now_size + ARC->T1->now_size) + (ARC->B2->now_size + ARC->T2->now_size)) >= ARC->size_ARC))
		{
			if (((ARC->B1->now_size + ARC->T1->now_size) + (ARC->B2->now_size + ARC->T2->now_size)) == ARC->size_ARC)
			{
				popBack(ARC->B2);
				replace(ARC, page);
				printf("p");
			}
		}
		else
		{
			pushFront(ARC->T1, page);
			hashTableAdd(ARC->hash_ARC, ARC->T1->head, page, 1);
			printf("a");
		}
	}
}

void replace(cash_ARC *arc, int page)
{
	if ((arc->T1->now_size >= 1) && ((((find_element(arc->B2, page) != NULL) && (arc->T1->now_size == *(arc->p)) || (arc->T1->now_size > *(arc->p))))))
	{
		int page = arc->T1->tail->val;
		popBack(arc->T1);
		hash_delete_elem(page, arc->hash_ARC);
		pushFront(arc->B1, page);
	}
	else
	{
		int page = arc->T2->tail->val;
		popBack(arc->T2);
		hash_delete_elem(page, arc->hash_ARC);
		pushFront(arc->B2, page);
	}
}

int main()
{
	int size = 5;
	cash_ARC *arc = init_cash(3);
	print_list(arc->T1);
	// pushFront(arc->T1, 7);
	// hashTableAdd(arc->hash_ARC, arc->T1->head, 7, 1);
	ARC(arc, 7);
	ARC(arc, 7);
	ARC(arc, 7);
	ARC(arc, 7);
	ARC(arc, 5);
	ARC(arc, 5);
	//  ARC(arc, 1);
	print_list(arc->T2);
	print_list(arc->T1);
	print_list(arc->B2);
	print_list(arc->B1);
	printf("%d\n", arc->T2->now_size);
	printf("%d\n", arc->T1->now_size);
	printf("%d\n", arc->B2->now_size);
	printf("%d\n", arc->B1->now_size);
	print_hash(arc->hash_ARC);

}
